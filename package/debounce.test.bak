import debounce from './debounce'
// import _ from 'lodash'
// const debounce = _.debounce

describe('debounce:', () => {
  let run, f

  beforeEach(() => {
    run = 0
    f = debounce(() => ++run, 100)
  })

  it('call once, then `func` will be invoked after `wait`', done => {
    const result = f()
    expect(result).toBeUndefined()
    setTimeout(() => {
      expect(run).toBe(1)
      done()
    }, 500)
  })

  it('call twice with short duration, the `func` will delay invoke after `lastCallTime + wait`', done => {
    let f = debounce(() => {
      run += 1
      return run
    }, 200)

    let result = f()
    setTimeout(() => {
      result = f()
    }, 100)

    setTimeout(() => {
      expect(result).toBeUndefined()
      expect(run).toBe(0)
    }, 250)

    setTimeout(() => {
      expect(result).toBeUndefined()
      expect(run).toBe(1)
      done()
    }, 500)
  })

  it('call twice with long duration, then `func` will be invoke twice and then second result is returnd by first invoked', done => {
    let result = f()
    setTimeout(() => {
      result = f()
    }, 200)

    setTimeout(() => {
      expect(run).toBe(1)
      expect(result).toBeUndefined()
    }, 150)

    setTimeout(() => {
      expect(run).toBe(2)
      expect(result).toBe(1)
      done()
    }, 500)
  })
})

describe('debounce: when `options.leading` is `true`', () => {

  let run, f
  beforeEach(() => {
    run = 0
    f = debounce(() => ++run, 100, { leading: true })
  })

  it('call once, the `func` will invoke by sync', () => {
    const result = f()
    expect(result).toBe(1)
  })

  it('call twice with short duration, the `func` will invoke at tailing edge', done => {
    f()
    expect(run).toBe(1)
    setTimeout(() => {
      f()
      expect(run).toBe(1)
    }, 50)
    setTimeout(() => {
      expect(run).toBe(2)
      done()
    }, 500)
  })

  describe('call twice with short duration', () => {
    let result
    beforeEach(() => {
      result = f()
      setTimeout(() => {
        result = f()
      }, 50)
    })

    it('the `func` will be invoked twice', done => {
      expect(run).toBe(1)
      setTimeout(() => {
        expect(run).toBe(2)
        done()
      }, 500)
    })

    it('then second result is returned by first call', done => {
      setTimeout(() => {
        expect(result).toBe(1)
        done()
      }, 500);
    })
  })

  describe('call twice with long duration', () => {
    let result
    beforeEach(() => {
      result = f()
      setTimeout(() => {
        result = f()
      }, 200)
    })

    it('the `func` will be invoked twice', done => {
      expect(run).toBe(1)
      setTimeout(() => {
        expect(run).toBe(2)
        done()
      }, 500)
    })

    it('the result', done => {
      expect(result).toBe(1)
      setTimeout(() => {
        result = f()
        expect(result).toBe(3)
        done()
      }, 500)
    })

  })
})



describe('debounce: when `options.trailing` is `false`', () => {
  let run, f

  beforeEach(() => {
    run = 0
    f = debounce(() => ++run, 100, {
      trailing: false
    })
  })

  it('call once, `func` will not invoke', done => {
    f()
    setTimeout(() => {
      expect(run).toBe(0)
      done()
    }, 500)
  })

  it('call twice with short duration, `func` will not invoke', done => {
    f()
    setTimeout(f, 50)
    setTimeout(() => {
      expect(run).toBe(0)
      done()
    }, 500)
  })

  it('call twice with long duration, `func` will not invoke', done => {
    f()
    setTimeout(f, 200)
    setTimeout(() => {
      expect(run).toBe(0)
      done()
    }, 500)
  })
})


describe('debounce: when `options.leading` is `true` and `options.trailing` is `false`', () => {
  let run, f

  beforeEach(() => {
    run = 0
    f = debounce(() => ++run, 100, {
      leading: true,
      trailing: false
    })
  })

  it('call once, the `func` will not invoke at tailing edge', done => {
    f()
    expect(run).toBe(1)
    setTimeout(() => {
      expect(run).toBe(1)
      done()
    }, 500)
  })

  it('call twice with short duration, the `func` will invoke at tailing edge', done => {
    f()
    expect(run).toBe(1)
    setTimeout(() => {
      f()
      expect(run).toBe(1)
    }, 50)
    setTimeout(() => {
      expect(run).toBe(2)
      done()
    }, 500)
  })

  it('call twice with long duration, the `func` will not invoke at tailing edge', done => {
    f()
    expect(run).toBe(1)
    setTimeout(() => {
      f()
      expect(run).toBe(2)
    }, 200)
    setTimeout(() => {
      expect(run).toBe(2)
      done()
    }, 500)
  })
})